package space.impact.impact_compat.common.item.materials.api

import gregtech.api.enums.Element
import gregtech.api.enums.FluidState
import gregtech.api.enums.IFluidState
import gregtech.api.fluid.GT_FluidFactory
import gregtech.common.items.GT_FluidDisplayItem
import space.impact.impact_compat.common.item.materials.texture.TextureCompatMaterial
import java.awt.Color

class CompatMaterialBuilder {

    private lateinit var material: CompatMaterial

    fun start(id: Int, localName: String, unificatable: Boolean = false): CompatMaterialBuilder {
        material = CompatMaterial(id = id, localName = localName, unificatable = unificatable)
        return this
    }

    fun addColor(color: Color): CompatMaterialBuilder {
        material = material.copy(color = color)
        return this
    }

    fun addTypes(vararg ores: OreDictionary): CompatMaterialBuilder {
        material = material.copy(orePrefixes = ores.toList())
        return this
    }

    fun addTexture(texture: TextureCompatMaterial): CompatMaterialBuilder {
        material = material.copy(icon = texture)
        return this
    }

    fun addChemicalFormula(formula: String): CompatMaterialBuilder {
        material = material.copy(chemicalFormula = formula)
        return this
    }

    fun addElement(element: Element): CompatMaterialBuilder {
        val formula = if (element == Element._NULL) "Empty" else element.toString().replace("_".toRegex(), "-")
        material = material.copy(chemicalFormula = formula)
        return this
    }

    fun addElements(vararg pairs: Pair<CompatMaterial, Int>): CompatMaterialBuilder {
        val matStack = pairs.map { CompatMaterialStack(it.first, it.second.toLong()) }
        material = material.copy(mMaterialList = matStack)
        val formula = if (material.mMaterialList.size == 1)
            material.mMaterialList.first().toString(true)
        else
            material.mMaterialList.joinToString("") { it.toString() }.replace("_", "-")
        material = material.copy(chemicalFormula = formula)
        return this
    }

    fun addSubTags(vararg tags: SubTags): CompatMaterialBuilder {
        material = material.copy(subTags = tags.toList())
        return this
    }

    fun addFluid(type: FluidType, temperature: Int = 300, isCustom: Boolean = false): CompatMaterialBuilder {
        val prefixLocal: String
        val prefixUnLocal: String
        val texture: String
        when (type) {
            FluidType.GAS -> {
                prefixUnLocal = ""; prefixLocal = ""
                texture = if (isCustom) "gas.${material.name.lowercase()}" else "autogenerated"
            }

            FluidType.MOLTEN -> {
                prefixUnLocal = "molten."; prefixLocal = "Molten "
                texture = if (isCustom) "molten.${material.name.lowercase()}" else "molten.autogenerated"
            }

            else -> {
                prefixUnLocal = ""; prefixLocal = ""
                texture = if (isCustom) material.name.lowercase() else "autogenerated"
            }
        }
        val rFluid = GT_FluidFactory.builder(prefixUnLocal + material.name.lowercase())
            .withLocalizedName(prefixLocal + material.localName)
            .withColorRGBA(material.rgba)
            .withTextureName(texture)
            .withStateAndTemperature(if (type == FluidType.GAS) FluidState.GAS else FluidState.LIQUID, temperature)
            .buildAndRegister()
            .asFluid()

        material = when (type) {
            FluidType.LIQUID -> material.copy(mFluid = rFluid)
            FluidType.GAS -> material.copy(mGas = rFluid)
            FluidType.MOLTEN -> material.copy(mStandardMoltenFluid = rFluid)
        }
        GT_FluidDisplayItem.addChemicalFormula(rFluid, material.chemicalFormula)
        return this
    }

    fun create(): CompatMaterial {
        return material.copy().also {
            CompatMaterial.MATERIALS_MAP[it.name] = it
        }
    }

    enum class FluidType(
        @JvmField val value: Int,
        @JvmField val state: String,
        isRegister: Boolean = false
    ) : IFluidState {

        GAS(FluidState.GAS),
        LIQUID(FluidState.LIQUID),
        MOLTEN(FluidState.MOLTEN);

        constructor(state: IFluidState) : this(state.value, state.state, false)

        init {
            if (isRegister) FluidState.VALID_STATES += this
        }

        override fun getState() = name
        override fun getValue() = value
    }
}