@file:Suppress("LeakingThis", "unused", "MemberVisibilityCanBePrivate")

package space.impact.impact_compat.common.item.meta

import cpw.mods.fml.relauncher.Side
import cpw.mods.fml.relauncher.SideOnly
import gregtech.api.interfaces.IIconContainer
import gregtech.api.util.GT_LanguageManager
import gregtech.api.util.GT_OreDictUnificator
import net.minecraft.creativetab.CreativeTabs
import net.minecraft.entity.player.EntityPlayer
import net.minecraft.item.Item
import net.minecraft.item.ItemStack
import net.minecraft.util.IIcon
import space.impact.impact_compat.common.item.materials.api.CompatMaterial
import space.impact.impact_compat.common.item.materials.api.CompatMaterial.Companion.GENERATED_MATERIALS
import space.impact.impact_compat.common.item.materials.api.CompatMaterial.Companion.MAX_MATERIALS
import space.impact.impact_compat.common.item.materials.GeneratedMaterials
import space.impact.impact_compat.common.item.materials.api.OreDictionary
import space.impact.impact_compat.core.Config
import java.util.*
import kotlin.math.min

abstract class MetaGeneratedItem32(unLocalName: String, vararg ores: OreDictionary) : MetaGeneratedItem(unLocalName, MAX_COUNT_AUTOGENERATED_ITEMS.toShort(), 766.toShort()) {

    companion object {
        fun getLocalizedNameForItem(aFormat: String, aMaterialID: Int): String {
            if (aMaterialID in 0 until MAX_MATERIALS) {
                val aMaterial = GENERATED_MATERIALS[aMaterialID]
                if (aMaterial != null) return aMaterial.getLocalizedNameForItem(aFormat)
            }
            return aFormat
        }
    }

    protected val mGeneratedPrefixList: Array<OreDictionary?>

    init {
        if (ores.size > 16) throw IndexOutOfBoundsException("Maximum ores for Item = 16")
        mGeneratedPrefixList = Arrays.copyOf(ores, 16)
        for (i in 0 until MAX_COUNT_AUTOGENERATED_ITEMS) {
            val ore = mGeneratedPrefixList[i / MAX_MATERIALS] ?: continue
            val mat = GENERATED_MATERIALS[i % MAX_MATERIALS] ?: continue
            if (doesMaterialAllowGeneration(ore, mat)) {
                val tStack = ItemStack(this, 1, i)
                GT_LanguageManager.addStringLocalization(getUnlocalizedName(tStack) + ".name", getDefaultLocalizationFormat(ore, mat, i))
                GT_LanguageManager.addStringLocalization(getUnlocalizedName(tStack) + ".tooltip", mat.getToolTip())
                GT_OreDictUnificator.registerOre(ore[mat], tStack)
            }
        }
    }

    /**
     * @return the Color Modulation the Material is going to be rendered with.
     */
    override fun getRGBa(stack: ItemStack?): ShortArray {
        val tMaterial = GENERATED_MATERIALS[getDamage(stack) % MAX_MATERIALS]
        return tMaterial?.rgba ?: GeneratedMaterials.NULL.rgba
    }

    /**
     * @param aPrefix   this can be null, you have to return false in that case
     * @param aMaterial this can be null, you have to return false in that case
     * @return if this Item should be generated and visible.
     */
    fun doesMaterialAllowGeneration(aPrefix: OreDictionary?, aMaterial: CompatMaterial?): Boolean {
        return aPrefix != null && aPrefix.doGenerateItem(aMaterial)
    }

    fun getDefaultLocalization(aPrefix: OreDictionary, aMaterial: CompatMaterial, meta: Int): String {
        return aPrefix.getDefaultLocalNameForItem(aMaterial)
    }

    fun getDefaultLocalizationFormat(aPrefix: OreDictionary, aMaterial: CompatMaterial, meta: Int): String {
        return aPrefix.getDefaultLocalNameFormatForItem(aMaterial)
    }

    fun getIconContainer(meta: Int, aMaterial: CompatMaterial?): IIconContainer? {
        val ore: OreDictionary? = mGeneratedPrefixList[meta / MAX_MATERIALS]
        return if (ore != null) aMaterial?.icon?.textures?.get(ore.ordinal) else null
    }

    fun doesShowInCreative(aPrefix: OreDictionary, aMaterial: CompatMaterial, aDoShowAllItems: Boolean): Boolean {
        return true
    }

    override fun getItemStackDisplayName(stack: ItemStack): String {
        val name = super.getItemStackDisplayName(stack)
        val aDamage: Int = stack.getItemDamage()
        return if (aDamage in 0 until MAX_COUNT_AUTOGENERATED_ITEMS) {
            getLocalizedNameForItem(name, aDamage % MAX_MATERIALS)
        } else name
    }

    override fun getIconContainer(meta: Int): IIconContainer? {
        return if (GENERATED_MATERIALS[meta % MAX_MATERIALS] == null) null else getIconContainer(meta, GENERATED_MATERIALS.get(meta % MAX_MATERIALS))
    }

    @SideOnly(Side.CLIENT)
    override fun getSubItems(aItem: Item, aCreativeTab: CreativeTabs?, aList: MutableList<Any?>) {
        for (i in 0 until MAX_COUNT_AUTOGENERATED_ITEMS) {
            val aPrefix = mGeneratedPrefixList[i / MAX_MATERIALS]
            val aMaterial = GENERATED_MATERIALS[i % MAX_MATERIALS]
            if (aPrefix != null && aMaterial != null) {
                if (doesMaterialAllowGeneration(aPrefix, aMaterial) && doesShowInCreative(aPrefix, aMaterial, Config.isDebug)) {
                    val tStack = ItemStack(this, 1, i)
                    isItemStackUsable(tStack)
                    aList.add(tStack)
                }
            }
        }
        super.getSubItems(aItem, aCreativeTab, aList)
    }

    override fun getIconFromDamage(meta: Int): IIcon? {
        if (meta < 0) return null
        if (meta < MAX_COUNT_AUTOGENERATED_ITEMS) {
            val tMaterial = GENERATED_MATERIALS[meta % MAX_MATERIALS] ?: return null
            return getIconContainer(meta, tMaterial)?.icon
        }
        return if (meta - MAX_COUNT_AUTOGENERATED_ITEMS < mIconList.size) mIconList[meta - MAX_COUNT_AUTOGENERATED_ITEMS][0] else null
    }

    override fun getItemStackLimit(stack: ItemStack): Int {
        val tDamage = getDamage(stack)
        return if (tDamage < MAX_COUNT_AUTOGENERATED_ITEMS && mGeneratedPrefixList[tDamage / MAX_MATERIALS] != null) {
            min(super.getItemStackLimit(stack), mGeneratedPrefixList[tDamage / MAX_MATERIALS]?.stackSize ?: 0)
        } else super.getItemStackLimit(stack)
    }

    override fun addToolTip(tooltips: MutableList<Any?>, stack: ItemStack, player: EntityPlayer) {
        super.addToolTip(tooltips, stack, player)
        val meta = stack.itemDamage
        if (meta in 0 until MAX_COUNT_AUTOGENERATED_ITEMS) {
            val mat = GENERATED_MATERIALS[meta % MAX_MATERIALS]
            if (mat != null && mat != GeneratedMaterials.NULL) {
                tooltips.add(mat.getToolTip())
            }
        }
    }
}
